import * as utils from './utils.js';
import { ValidationResult } from './validation-result.js';

class ValidatorInternalState {

    #name;
    #mode;
    #contextValue;
    #contextValuePath;
    #contextValueCurrentPath;
    #errorPrefix;
    #errorBasePath;
    #errorContextPaths;
    #errorContextValuePaths;
    #validationResult;

    constructor(name) {
        this.#name = name;
    }

    _init(mode, contextValue, contextValuePath, contextValueCurrentPath, errorPrefix, errorBasePath, errorContextPaths, validationResult) {
        this.#mode = mode;
        this.#contextValue = contextValue;
        this.#contextValuePath = contextValuePath;
        this.#contextValueCurrentPath = contextValueCurrentPath;
        this.#errorPrefix = errorPrefix;
        this.#errorBasePath = errorBasePath;
        this.#errorContextPaths = errorContextPaths;
        this.#errorContextValuePaths = undefined; // calculated in the property getter
        this.#validationResult = validationResult;
    }

    get mode() {
        return this.#mode;
    }

    get contextValue() {
        return this.#contextValue;
    }

    get contextValuePath() {
        return this.#contextValuePath;
    }

    get contextValueCurrentPath() {
        return this.#contextValueCurrentPath;
    }

    get errorPrefix() {
        return this.#errorPrefix;
    }

    get errorBasePath() {
        return this.#errorBasePath;
    }

    get errorContextPaths() {
        return this.#errorContextPaths;
    }

    /**
     * Gets the errorContextValuePaths for this validator context.
     * Even though only one contextPath can exist for a validator context, it
     * can still have multiple errorContextValuePaths because errorContextPaths allows multiple
     * paths to be set. So if multiple errorContextPaths are set, multiple errorContextValuePaths will be produced
     * and should all be added as failed paths in the case of the validation context failing.
     * @returns {string[]} the contextValuePath prefixed with errorBasePath (if set) and post-fixed with errorContextPaths (if set)
     */
    get errorContextValuePaths() {
        if (!this.#errorContextValuePaths) {
            let paths = [];
            if (this.#errorContextPaths === undefined) {
                paths.push(utils.joinPropPaths(this.#errorBasePath, this.#contextValuePath));
            } else {
                for (let errorContextPath of this.#errorContextPaths) {
                    paths.push(utils.joinPropPaths(this.#errorBasePath, errorContextPath));
                }
            }
            this.#errorContextValuePaths = paths;
        }

        return this.#errorContextValuePaths;
    }

    /**
     * @returns {ValidationResult}
     */
    get validationResult() {
        return this.#validationResult;
    }

    getFullErrorMessage(errorMessage) {
        let fullMessage = errorMessage;
        if (this.#errorPrefix) {
            fullMessage = `${this.#errorPrefix} ${errorMessage}`;
        }
        return fullMessage;
    }

    /**
     * @param {ValidatorInternalState} dest - The dest to clone to.
     * @param {string} contextValue - The contextValue for the clone.
     * @param {string} [contextValuePath] - The contextValuePath for the clone, if `undefined` the contextValuePath from this instance will be used.
     * @param {string} [contextValueCurrentPath] - The contextValueCurrentPath for the clone, if `undefined` the contextValueCurrentPath from this instance will be used.
     * @param {string[]} [errorContextPaths] - Rewrite the `errorContextValuePaths` generated by this validator and sub validators.
     * If the current instance has `errorContextPaths` set and the clone does not explicitly overwrite them, the clone will have a new set of `errorContextPaths`
     * with the `contextValueCurrentPath` added for each of them to account for the new child context.
     * @returns {ValidatorInternalState}
     */
    cloneWith(dest, contextValue, contextValuePath, contextValueCurrentPath, errorContextPaths) {
        let newContextValuePath = contextValuePath === undefined ? this.#contextValuePath : contextValuePath;
        let newContextValueCurrentPath = contextValueCurrentPath === undefined ? this.#contextValueCurrentPath : contextValueCurrentPath;
        let newErrorContextPaths = errorContextPaths === undefined ? this.#errorContextPaths : errorContextPaths;

        // when we have a nested context with a defined errorContextPaths, and it is inherited from its parent, add the contextValueCurrentPath to it, so nested
        // paths are taken into to context for each of the errorContextPaths
        if (this.#errorContextPaths && this.#errorContextPaths === newErrorContextPaths && newContextValueCurrentPath !== this.#contextValueCurrentPath) {
            newErrorContextPaths = [];
            for (let errorContextPath of this.#errorContextPaths) {
                newErrorContextPaths.push(utils.joinPropPaths(errorContextPath, newContextValueCurrentPath));
            }
        }
        dest._init(this.mode, contextValue, newContextValuePath, newContextValueCurrentPath, this.errorPrefix, this.errorBasePath, newErrorContextPaths, this.validationResult);
        return dest;
    }

}

export { ValidatorInternalState };